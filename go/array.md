---
title: "GoLang-数组"
date: 2019-03-26T22:25:25+08:00
description: GoLang中的数组
draft: true
---


### 数组声明

由于Go语言是一种强类型的语言，所有的变量都必须先声明后使用，因此数组的声明有以下几种方式:

1. 先声明数量和类型，未赋值的话，将初始化未数组元素类型的零值。

    ```go
        var a [2]int
    ```

1. 声明的时候，同时赋值,未赋值的元素，将使用元素的零值
    ```go
        var a = [2]int{2}
    ```

1. 利用编译的时候自动推导出数组的长度，因此可以使用`...`来省略数组的长度
    ```go
        var a = [...]int{2, 3, 4}
    ```

1. 当然也可以使用短语法来声明一个数组
    ```go
        a := [...]int{2,3}
    ```


### 数组类型

在Go中，数组表示相同类型的元素集合，数组是一种类型，简写为:`n[T]`,由此可见，数组这种类型是由数量`n`和类型`[T]`两部分组成的,包含相同类型，但是元素不同的两个数组属于两个不同的数组类型

```go
var a = [2]int{2, 3}
var b = [2]int{2}
var c = [1]int{3}

b = a
c = a //将会报错误:cannot use a (type [2]int) as type [1]int in assignment
fmt.Println(a, b, c)

```
以上，将数组`a`赋值给`b`是允许的，因为他们的元素类型和元素数量相同，反之，将`a`赋值给`c`是不被允许的，虽然他们的元素的类型相同，但是他们的元素的数量不一致，因此他们属于不同的数组类型。

由于数组在Go中是一种值类型而不是反射类型，因此当我们将数组赋值给一个变量的时候，实际上是对原数组进行一个复制，对于新数组的变更，将不会作用与旧的数组，看下面一个例子
```go
var a = [...]int{2, 3, 4}
b := a
fmt.Println("array a:", a)
fmt.Println("array b:", b)

b[0] = 20

fmt.Println("array a:", a)
fmt.Println("array b:", b)
```
输出的结果如下图所示:
```
array a: [2 3 4]
array b: [2 3 4]
array a: [2 3 4]
array b: [20 3 4]
```

既然数组中的元素数量也是数组类型的一部分，因此我们可以通过使用`len`函数来获取数组的长度属性。就像下面这个例子

```go
var a = [2]int{2, 3}

fmt.Println(len(a)) //将会输出：2
```

### 数组的操作

对于数组而言，其常用的操作是一个遍历，Go提供一个有用的`for...range`结构来便利一个数组
```go
var a = [...]int{2, 3, 4}

for k, v := range a {
    fmt.Printf("index is:%d, value is:%d \n", k, v)
}
```
其输出结果为：
```
index is:0, value is:2 
index is:1, value is:3 
index is:2, value is:4 
```


尽管Go中的数组看起来足够的灵活，但是长度是其类型的一部分，这就限定了数组的可用性。

因为一旦声明的时候定义数组的长度，那么数组的长度后期是不能再增长或减少的，为了解决这个问题，在Go中引入了`slice(切片)`的概念

