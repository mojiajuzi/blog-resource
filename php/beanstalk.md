---
title: "Beanstalk 协议"
date: 2018-06-22T17:13:23+08:00
draft: true
---

beanstalk协议以ASCII编码运行在TCP协议上；客户端的执行的周期为：连接服务，发送命名和数据，等待响应，关闭连接，对于一个连接而言；服务端进程而言，接收命令和做出响应具有相同的优先级；所有的数字都将转换成无符号的十进制整型．


命名，对于ASCII字符串而言，名字可以包含字母(A-Z, a-z), 数字(0-9),横线('-'),加号('+'), 斜线("/"), 分号(";"), 顿号("."), 美元符号("$"),以及括号("()")，但是不能以横线作为开头．字符串以空白符结尾，但是每一个名字至少包含一个字符

该协议包含两种数据格式，文本行，非结构化的数据块．其中文本行主要用于客户端命令和服务端响应，数据块常用来保存任务详情以及状态．每一个消息体
都是一个字节序列，服务端不会对消息进行检查和修改，只会原样返回,这样使得客户端能够正确的解析消息

Beanstalk中并没有用于关闭连接的命令，客户端如果长时间未使用服务将会自动关闭TCP连接，对于Beanstalk而言，能够同时保持大量的连接，对于客户端而言就能够更好的保持连接以及重用连接，这样就避免了创建新的TCP连接带来的额外开销

如果客户端违反协议(如:发送非法格式请求数据,命令不存在)或者服务端发生了错误，客户端将会返回如下的错误信息

    - "OUT_OF_MEMORY\r\n" 内存不足，服务端无法分配足够的内存用于消息的执行，客户端需要等待一段时间再尝试发送
    
    - "INTERNAL_ERROR\r\n" 内部错误，服务端出现了BUG
    
    - "DRAINING\r\n" 服务端不再接受新的消息，客户端需要尝试连接其他的服务或者关闭服务
    
    - "BAD_FORMAT\r\n" 客户端发送了错误的数据格式
    
    - "UNKNOWN_COMMAND\r\n"　客户端发送了错误的命令

任务的生命周期
-------------

当一个任务被客户端使用`put`方法创建以后，在其整个生命周期中，必定会处于以下几个状态：

- ready 任务处于队列中，等待被执行
- reserved 任务被执行完,保留状态
- delayed　延迟执行
- buried　隐藏状态

如下的显示了任务的一般生命周期

```asciiarmor
		   put            reserve               delete
  -----> [READY] ---------> [RESERVED] --------> *poof*
```

如下则显示了更为复杂的生命周期

```
   put with delay               release with delay
  ----------------> [DELAYED] <------------.
                        |                   |
                        | (time passes)     |
                        |                   |
   put                  v     reserve       |       delete
  -----------------> [READY] ---------> [RESERVED] --------> *poof*
                       ^  ^                |  |
                       |   \  release      |  |
                       |    `-------------'   |
                       |                      |
                       | kick                 |
                       |                      |
                       |       bury           |
                    [BURIED] <---------------'
                       |
                       |  delete
                        `--------> *poof*
```



一个队列系统包含一个或者多个管道组成，而每一个管道是由`ready queue`和`delay queue`队列组成，任务则是被生产者推送到管道中的队列中

一个消费者可以通过`watch`命令来订阅管道，一个消费者可以订阅多个管道，这些管道则组成了消费者的订阅列表，当然也可以通过`ignore`命令来取消订阅

当一个客户端连接时，将会默认的订阅一个名为`default`的管道，当推送任务时，如果没有使用`use`命令指定推送的管道名称，将会被推送到`default`管道中

引用一个管道的时候，如果管道存在，将会被创建，如果一个管道的队列上没有任务并且没有消费者，那么该管道将会被删除

生产者命令
-------------

使用`put`命令将一个任务插入到队列中，其形式如下

```
put <pri> <delay> <ttr> <bytes>\r\n
<data>\r\n

```

- `pri` < 2**32的整型，数字越小任务的执行优先级越高，最小值为：0, 最大值为：4294967295
- `delay` 任务延迟加入到`ready queue`队列的时间，单位为:秒，在这个时间范围内，任务的状态为`delayed`
- `ttr` 任务执行的超时时间，单位为：秒，该时间从任务开始执行时计算，如果在这个时间内任务没有删除，重新加入，隐藏，那么该任务就会超时，任务将会被重新加入队列
- `bytes` 任务体的大小，不包括`\r\n`换行符，其最大值为`2**16` byte
- `data` 任务体

当发送一个任务以后，客户端将会等待回复，那么可能会出现一下回复

- `INSERTED <id> \r\n` 任务写入成功，并返回任务的`id`标识
- `BURIED <id>\r\n` 优先级队列已经耗尽内存，任务状态将会被设定为`BURIED`
- `EXPECTED_CRLF\r\n` 消息体没有结束符号`\r\n`
- `JOB_TOO_BIG\r\n` 消息体大小超过限制

对于生产者而言，使用`use`命令可以在推送任务的时候指定特定的管道，如果不使用，则会将任务推送到`default`管道

```
use <tube> \r\n
```

- `tube` 管道名称，名称长度不得超过200 bytes,如果管道不存在，将会被直接创建

使用`use`命令时，将会返回`USING <tuber>\r\n`



任务执行命令
---------------

当一个进程执行任务的时候将会使用`reserve`, `delete`,`release`,`bury`等命令，首先来看一下`reserve`命令

```
reserve\r\n
```

为了指定执行的时间，可以使用如下命令

```
reserve-with-timeout <seconds>\r\n
```

执行`reserve`的时候将会返回新的正在被执行的任务，如果队列中没有任务，将会一直等到有可用任务的时候，才会返回响应,

如果客户端在任务指定的时间内没有执行完任务，服务端将会将任务重新加入`ready`队列，超时时间以及剩余时间，可以通过`stats-job`命令得到



在执行期间，设定超时时间的最后一秒将会是服务器的安全边界条件，在这个时间内，客户端将不会被强制要求等待下一个任务，如果在安全边界期间或者安全边界

时间到了，那么客户端将会等待一个执行任务，服务端将会做出如下的可能响应

```
DEADLINE_SOON\r\n
```

在服务端自定自动将任务放到`ready`队列之前，客户端还有最后一次机会对任务进行处理(删除或者放到`ready`队列)

```
TIME_OUT\r\n`
```
超时时间结束时，队列中没有任务执行，将会返回超时


```
RESERVED　<id> <bytes> \r\n
<data>\r\ndata
```

通过使用`delete`命令可以讲处在其他状态的任务进行删除

```
delete <id>\r\n
```

执行删除后，可能的响应为:

- `DELETED\r\n` 删除成功
- `NOT_FOUND\r\n` 任务不存在

使用`release`可以将任务重新放到`ready`队列，这样任务就可以重新被其他的客户端使用

```
release <id> <pri> <delay> \r\n
```

客户端可能会接收下列响应

- `RELEASED\r\n` 执行成功
- `BURIED\r\n` 执行成功，由于内存不足，任务将会被隐藏
- `NOT_FOUND\r\n` 任务无法找到

使用`bury`可以使得一个任务对客户端不可见

```
bury <id> <pri>\r\n
```

客户端可能会接收到的响应为

- `BURIED\r\n` 执行成功
- `NOT_FOUND\r\n` 任务不存在

使用`touch`命令可以更新当前任务的属性，对于那些需要长时间执行的任务是非常有效的

```
touch <id>\r\n
```

- `TOUCHER\r\n` 执行成功
- `NOT_FOU\r\n` 任务不存在或者任务尚未执行

通过`watch`命令，消费者可以订阅多个管道,执行后将会返回去订阅的管道总和`WATCHING <count>\r\n`

```
watch <tube>\r\n
```

相反的,通过`ignore`命令,可以将订阅的管道从列表中删除

```
ignore <tube> \r\n
```

取消订阅后,可能的响应结果为

- `WATCHING <count>\r\n`
- `NOT_IGNORED\r\n` 如果订阅列表中只有一个管道,将会返回该值



其他命令
---------------